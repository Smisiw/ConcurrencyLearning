## SafeCounter - Реализация счетчика с потокобезопасностью
### **Анализ результатов**
#### **1. Тест с 1000 потоками (создание отдельных потоков)**
| Реализация         | Время (нс)  |
|--------------------|------------|
| `LongAdderSafeCounter` | 247123 |
| `AtomicSafeCounter` | 304237 |
| `SynchronizedSafeCounter` | 417735 |
| `LockSafeCounter` | 554341 |

- **Лучший результат у `LongAdderSafeCounter`**  
  `LongAdder` спроектирован для высокой конкуренции, он использует сегментацию, чтобы уменьшить блокировки между потоками. Поэтому он эффективнее при большом количестве потоков.  

- **Хуже всего работает `LockSafeCounter`**  
  `ReentrantLock` вызывает накладные расходы на блокировки и снятие блокировок. Потоки вынуждены ожидать освобождения `lock`, что приводит к задержкам.  

#### **2. Тест с ThreadPoolExecutor (10 потоков)**
| Реализация         | Время (нс)  |
|--------------------|------------|
| `LongAdderSafeCounter` | 119927 |
| `AtomicSafeCounter` | 79861 |
| `SynchronizedSafeCounter` | 779631 |
| `LockSafeCounter` | 1678200 |

- **Лучший результат у `AtomicSafeCounter`**  
  В условиях фиксированного количества потоков `AtomicInteger` работает лучше, так как не требует дополнительных структур данных, как `LongAdder`.  

- **Плохая работа `SynchronizedSafeCounter` и `LockSafeCounter`**  
  `synchronized` приводит к высокому числу блокировок, а `ReentrantLock` ещё хуже справляется с конкуренцией в пуле потоков. Это объясняет значительно большие значения времени выполнения.
